# Iterate over each row in the original DataFrame
for row_index, row in df.iterrows():
    # Get the most recent non-null numerical data and corresponding ranking data
    most_recent_numerical = row[numerical_columns].dropna().iloc[-1]
    most_recent_ranking = row[ranking_columns].dropna().iloc[-1]
    
    # Calculate the position of the previous year's data
    previous_year_position = row_index[0] - 4
    
    # Get the previous year's data for both numerical and ranking columns
    previous_numerical = df.loc[previous_year_position, numerical_columns].dropna()
    previous_ranking = df.loc[previous_year_position, ranking_columns].dropna()
    
    # Create tuples for the multi-level index
    index_tuples = [(row_index, col) for col in numerical_columns] + [(row_index, col) for col in ranking_columns]
    
    # Create a row with the current and previous year values
    row_values = list(most_recent_numerical.values) + list(previous_numerical.values) + \
                 list(most_recent_ranking.values) + list(previous_ranking.values)
    
    # Append the row to the result DataFrame
    result_df = result_df.append(pd.Series(row_values, index=result_df.columns, name=index_tuples))

# Print the result DataFrame
print(result_df)
In this code, we iterate over each row in the original DataFrame using iterrows(). For each row, we extract the most recent non-null numerical data and ranking data using dropna() and iloc[-1]. We calculate the position of the previous year's data, retrieve the previous year's data using loc, and drop the null values. We create tuples for the multi-level index, create a row with the current and previous year values, and append the row to the result DataFrame.

Please replace 'df' with the actual name of your DataFrame, and run the code to generate the desired output.






